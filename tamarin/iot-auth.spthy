theory IoT_Auth
begin

builtins: hashing, symmetric-encryption

// Setup: create a device id and a shared initial vault for that device
rule Create_Vaults:
  [ Fr(~v0)]
  --[ Setup($did, ~v0) ]->
  [ !VaultD($did, ~v0),
    !VaultS($did, ~v0) ]

// M1: device -> server  (device id, session id)
rule Device_Hello:
  [ !VaultD($did, v),
    Fr(~sid) ]
  --[ DeviceHello($did, ~sid) ]->
  [ Out(<'M1', $did, ~sid>),
    SessionD($did, ~sid, v) ]

// M2: server -> device  (challenge)
rule Receive_Device_Hello_Response:
    [ !VaultS($did, v),
      In(<'M1', $did, sid>),
      Fr(~c1),       // challenge indices (modeled as fresh)
      Fr(~r1)        // random value r1
    ]
    --[ ServerReceiveHello($did, sid, ~c1, ~r1) ]->
    [ Out(<'M2', ~c1, ~r1>),
      SessionS($did, sid, v, ~c1, ~r1) ]

// M3: device -> server  (response to challenge)
rule Device_Challenge_Response:
    let 
        k1 = h(<v, c1>)               // derive key from vault + challenge indices
        payload = <r1, ~t1, ~c2, ~r2> // response and new challenge
        m3 = senc(payload, k1)        // encrypt message contents with derived key
    in    
    [ SessionD($did, sid, v),
      In(<'M2', c1, r1>),
      Fr(~t1),                   // fresh random value t1
      Fr(~c2),                   // fresh challenge indices for server
      Fr(~r2) ]                  // fresh random value r2
    --[ DeviceChallengeResponse($did, sid, c1, r1, ~c2, ~r2) ]->
    [ Out(<'M3', m3>), 
      SessionD_updated($did, sid, v, ~t1, ~c2, ~r2) ]

// M4: server -> device  (response to challenge)
rule Server_Challenge_Response:
    let 
    k1 = h(<v, c1>)                 // derive key 1 (same method as device)
    k2 = h(<v, c2>)                 // derive key 2 (same method as device)
    t = h(t1, ~t2)                  // shared session key
    in    
    [ SessionS($did, sid, v, c1, r1),
      In(<'M3', senc(<r1, t1, c2, r2>, k1)>),
      Fr(~t2) ]                  // fresh random value t2
    --[ ServerCreateSession($did, sid, t) ]->
    [ Out(<'M4', senc(<r2, ~t2>, k2)>),
      SessionS_final($did, sid, v, t) ]

// Final step: device processes server's response
rule Device_Finalize:
    let
    k2 = h(<v, c2>)                 // derive key (same method as server)
    t = h(t1, t2)                   // shared session key
    in
    [ SessionD_updated($did, sid, v, t1, c2, r2),
      In(<'M4', senc(<r2, t2>, k2)>)]
    --[ DeviceCreateSession($did, sid, t) ]->
    [ SessionD_final($did, sid, v, t) ]

rule End_Session_for_Device:
    let
    new_v = h(v, t)                   // HMAC on vault using the session key
    in
    [ SessionD_final($did, sid, v, t),
    !VaultD($did, v) ]
    --[ EndSessionD($did, sid, new_v) ]->
    [ Out(<'EndSessionD', $did, sid>),
      !VaultD($did, new_v) ]

rule Update_Server_Vault:
    let
    new_v = h(v, t)                   // HMAC on vault using the session key
    in    
    [ In(<'EndSessionD', $did, sid>),
    SessionS_final($did, sid, v, t),
    !VaultS($did, v) ]
    --[ UpdateVaultS($did, sid, new_v) ]->
    [ !VaultS($did, new_v) ]

// Needed for Lemmas
rule Reveal_Vault:
  [ !VaultD(did, v) ]
  --[ VaultReveal(did) ]->
  [ Out(v) ]

lemma Session_executability:
  exists-trace
"
  Ex did sid t v #i #j #k.
    Setup(did, v) @ #i
  & DeviceHello(did, sid) @ #j
  & DeviceCreateSession(did, sid, t) @ #k
  & not(Ex #r. VaultReveal(did) @ #r)
"

  lemma Vault_secrecy:
"
  not(Ex did v #i #k.
      Setup(did, v) @ #i
    & K(v) @ #k
    & not(Ex #r. VaultReveal(did) @ #r)
  )
"

lemma Session_key_secrecy:
"
  not(Ex did sid t #i #j #k.
      ServerCreateSession(did, sid, t) @ #i
    & DeviceCreateSession(did, sid, t) @ #j
    & K(t) @ #k
    & not(Ex #r. VaultReveal(did) @ #r)
  )
"



end
